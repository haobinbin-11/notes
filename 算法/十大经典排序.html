<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
// ================================================== 冒泡排序
                // 原理 从下标第0项开始  依次比较相邻两项然后交换位置 最终把一个最大值或者最小值换到第一项 剩余继续比较交换位置 最终排序
                // var arr = [1,5,3,7,12,6,45,34,567,900]; // 定义一个数组
                // var max; // 声明一个最大值, 用来当交换位置
                // for(var i = 0; i<arr.length-1;i++){  // 定义比较的次数
                //     for(var j = 1;j<arr.length-i;j++){   //每一个需要比较几次 
                //         if(arr[j-1]<arr[j]){
                //             max = arr[j];           // 交换位置
                //             arr[j] = arr[j-1]
                //             arr[j-1]  = max
                //         }
                //     }
                // }
                // console.log(arr);
// ================================================== 快速排序
                //原理   
                // 1. 找到并取出数组的中间项 
                // 2. 准备左右两个数组 
                // 3. 用原数组剩下的项与中间项比较 大于中间项 放入左 小于放入右
                // 4. 用concat拼接数组 左.concat(中间项,右)
                // 5. 使用递归 让左右两个数组重复执行
                // 6. 当左或者右数组 只剩一项 或者为<一项 返回当前数组
                // var  arr = [23,42,5,6,7,58,65,54,48,3,];
                // function fast(arr){
                //     // 当只有一项或者小于一项 返回当前
                //     if(arr.length<=1){
                //         return arr;
                //     }

                //     var middleIndex = Math.floor(arr.length/2); // 获取中间项下标
                //     var middleValue = arr.splice(middleIndex,1)[0]  // 从原数组中取出中间项
                //     var left_arr= [];
                //     var right_arr= [];
                //     // 循环比较
                //     for(var i =0;i<arr.length;i++){
                //         var one = arr[i]; // 当前项
                //         one>middleValue?left_arr.push(one):right_arr.push(one);
                //     }
                //     return fast(left_arr).concat(middleValue,fast(right_arr))
                // }
                // arr = fast(arr);
                // console.log(arr);
                

// ================================================== 插入排序
            // 原理
            //  1. 准备一个新数组 放入从原数组拿出的第一项
            //  2. 循环原数组剩下的项 与新数组每一项从后往前比较  
            //  3. 当大于新数组这一项则放在后面 小于则往前比较 如果一直到最前 则放到第一项
            //  4. 返回新数组
            // var  arr = [23,42,5,6,7,58,65,54,48,3,];
            // var newarr = [];
            // newarr.push(arr[0]);
            // for(var i = 1;i<arr.length;i++){
            //     var one = arr[i] // 当前项
            //     for(var j =newarr.length-1;j>=0;j--){
            //         if(one>newarr[j]){
            //             newarr.splice(j+1,0,one);
            //             break;  // 结束当前循环
            //         }
            //         if(j===0){
            //             newarr.unshift(one)
            //         }
            //     }
            // }
            // console.log(newarr);
// ================================================== 选择排序
            // 原理 
            //  1. 循环数组中每个值  假设一个最大值下标;
            //  2. 循环剩下的项 让每一项与这个假设项比较 
            //  3. 若果大于假设项 则让最大值小标为当前的下标 然后继续比较
            //  4. 找到数组最大值下标 然后与第一项下标交换 
            //  5. 重复比较
            var arr = [2,5,4,9,7,10,3,1];
            for(var i =0; i<arr.length;i++){
                var maxIndex = i;
                for(var j = i+1; j <arr.length;j++){
                    if(arr[j]>arr[maxIndex]){
                        maxIndex = j;
                    }
                }
                [arr[maxIndex], arr[i]] = [arr[i],arr[maxIndex]]
            }
            console.log(arr);
            
    </script>
</body>
</html>